---
layout: post
tags: [virtual memory virtual texture cpu cache]
---
#### Virtual Memory

虚拟内存。CPU允许每个进程独享一个虚拟内存空间，大小可以远超物理内存(例如允许虚拟内存地址直接映射到硬盘地址)。
虚拟内存有几个比较重要的概念:
* 最小寻址单元: Byte 字节
* 最小读写单元: Word 字长 32位CPU一般是4字节，64位8字节
* 页: Page 一般是4KB，可修改为2MB，1GB等

虚拟内存寻址一般是由CPU的MMU(内存管理单元)进行管理，负责VA(Virtual Address)虚拟地址到PA(Physical Address)物理地址的转换。
此转换过程需要借助一个被称之为PageTable(页表)的数据结构来完成，而VA一般由两部分组成:页表索引+偏移，所以转换大致分为两个步骤:
1. 通过页表索引在页表中查询到物理Page的地址
2. 将该地址加上偏移就是最终物理地址

如果把所有页表索引都放在一个页表中，那么页表就会非常大，结构也可能十分松散。因此引入了多级页表的概念，通过索引在非末级页表中查询到的是下一级页表的地址，以此类推。查询次数与级数相关。CPU提供了专门的存储单元来存放页表。

### Virtual Texture

虚拟贴图。使用了虚拟内存的思想优化贴图占用。即虚拟内存大小可以远超物理内存。
假设需要渲染一张超大的贴图(16k * 16k)到1k * 1k的屏幕，分两种情况：
1. 将整张贴图渲染到屏幕：直接加载对应的mipmap即可，注意是动态加载，而不是将全部的mipmap全部放进显存
2. 渲染贴图的一部分到屏幕：如果采取1的做法，会导致贴图看不见的那部分也被加载到了显存

为了解决2带来的问题，借助虚拟内存引入虚拟贴图的概念，大致步骤如下：
* 将超大贴图视为一张虚拟贴图，场景上的物体的uv需要重新烘培绑定到这张虚拟贴图
* 将虚拟贴图均分成二维网格，每个格子代表一个Page，也对应一张物理贴图
* 通过摄像机预渲染一次场景，输出的像素值里保存了虚拟贴图的Page索引
* 加载Page所对应的物理贴图，并将所有的物理贴图打包放在一个Atlas中，另外新建一个页表贴图，记录Page与Atlas物理贴图的位置关系

以上准备工作完成之后，就可以开始渲染真实场景了。着色过程中涉及到的虚拟贴图uv到Atlas贴图的uv的转换其实就是VA到PA的转换，也就是着色器负担起了MMU的职责。而页表贴图就是寻址过程中用到的页表。